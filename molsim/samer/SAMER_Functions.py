__all__ = ['file_to_dict', 'gen_continuum', 'gen_pixel_dict', 'pixel_hopping', 
'create_params', 'store_params', 'read_params', 'update_params', 'calc_mean_params', 
'obs_exclusion', 'min_function', 'fit_initial_column', 'fit_row', 'mp_helper', 'fit_multiprocessing',
'plot_fit', 'plot_fit_multi', 'print_lines_from_fit', 'pull_fits_header_info', 'create_figure']

# import analysisUtils as au
# import toddTools as tt
import numpy as np
import scipy.optimize
import matplotlib
import matplotlib.pyplot as plt
from molsim.utils import _trim_arr, find_nearest, _make_gauss, _apply_vlsr, find_limits, find_peaks, _get_res, _find_nans, _find_limit_idx, generate_spcat_qrots, process_mcmc_json
from molsim.classes import Workspace, Catalog, Transition, Level, Molecule, PartitionFunction, Spectrum, Simulation, Continuum, Source, Observatory, Observation, Iplot, Trace
from molsim.functions import sum_spectra, velocity_stack, matched_filter, convert_spcat, resample_obs
from molsim.stats import get_rms
import json
import time
from astropy.io import fits
from astropy.coordinates import SkyCoord
from astropy import units as u
from astropy.wcs import WCS
import pathlib
import glob
import os
import lmfit
from lmfit import Model, Parameters, Minimizer, report_fit
from lmfit.models import GaussianModel
from SAMER_Classes import Fitting_Variables, Pixel, Molecule_Parameters
from molsim.file_handling import load_obs
import multiprocessing as mp
from concurrent.futures import ProcessPoolExecutor
from scipy import stats, signal
import cmasher



def file_to_dict(file):
	#Function to take both pos_key and continuum files from extract_spectra() and return them in dictionaries

	#Should only be dealing with files generated by extract_spectra(), so should have advance knowledge of everything in the directory
	if 'cont' in file:
		with open(file, 'r') as content:
			return_dict = json.load(content)
	
	elif 'pos_key' in file:
		return_dict = dict()
		with open(file, 'r') as infile:
			contents = infile.readlines()
			for ele in contents:
				temp = ele.split('\t')
				return_dict[temp[0]] = temp[1].strip()

	else:
		print('?!!!')
	
	return return_dict
	
def gen_continuum(spectra_dir, obs, pixel, cont_key=None):
	#Return a Continuum object given a set of continuum values and observations
	#Default behavior allows for a single continuum value, or any even split of spectral windows per continuum value
	#Setting cont_key (iterable of integers) tells the function how many times to use each continuum value

	#Pull the continuum information from the extract_spectra() file
	cont_values = file_to_dict(glob.glob(spectra_dir+'*cont_values*')[0])

	#Need the limits to know which continuum value to apply
	ll,ul = find_limits(obs.spectrum.frequency)
	
	#Value to check how many continuum measurements are available
	cont_spws = len(cont_values['0_0'])

	#Holds the list of information for each spectra window [ll, ul, cont_value]
	cont_params = []
	
	if cont_key is None:
		#If there is only one continuum value to apply to multiple spectral windows, apply appropriately
		if cont_spws == 1:
	
			for i in range(len(ll)):
				cont_params.append([ll[i],ul[i],float(cont_values[pixel][0])])
				cont = Continuum(type = 'range', params = cont_params)

			return cont
		
		#If the number of continuum measurements divides cleanly into number of spectral windows assign them evenly
		elif len(ll) % cont_spws == 0:
		
			#The number of spectral windows that share the same continuum value
			spws_per_cont_measurement = len(ll) / cont_spws
		
			total_count = 0
			for i in range(cont_spws):
				for j in range(spws_per_cont_measurement):
					cont_params.append([ll[total_count],ul[total_count],float(cont_values[pixel][i])])
					total_count += 1
				
			cont = Continuum(type = 'range', params = cont_params)
				
			return cont 
		
		else:
		
			print('Mismatch in number of spectral windows and number of continuum measurements!')
			print('find_limits() found '+str(len(ll))+' chunks of data:')
			for i in range(len(ll)):
				print(ll[i], ul[i])
			print(f'This does not evenly split between {cont_spws} continuum measurements')
			print('Please define how the continuum values should be applied using gen_continuum_key()')
		
			return
	else:
		#Create a new list that duplicates the entries in cont_values[pixel] as necessary to make the length equal to len(ll)
		new_cont_list = []
		for i,xval in enumerate(cont_key):
			count = 0
			while count < xval:
				new_cont_list.append(float(cont_values[pixel][i]))
				count += 1
				
		for i in range(len(new_cont_list)):
			cont_params.append([ll[i], ul[i], new_cont_list[i]])
			
		cont = Continuum(type = 'range', params = cont_params)
		
		return cont
		
def gen_pixel_dict(fitting_variables):
	#Generate a dictionary such that the key ('X_Y') corresponds to the appropriate Pixel object. 
	#This is the primary way that users will interact with the Pixel objects

	#Pull the appropriate pixel information from the results of extract_spectra()
	pos_key = file_to_dict(glob.glob(fitting_variables.spectra_dir+'*pos_key*')[0])

	#The dictionary that associates each pixel key ('X_Y') with the appropriate Pixel object and set the appropriate attributes
	pixel_dict = dict()

	for pixel in pos_key:

		pixel_dict[pixel] = Pixel()

		if len(glob.glob(f'{fitting_variables.spectra_dir}*_{pixel}.txt')) > 1:
			print('There are too many files with the same pixel number!')
			return

		obs = load_obs(glob.glob(f'{fitting_variables.spectra_dir}*_{pixel}.txt')[0], type='txt', observatory=fitting_variables.observatory)
		#Make sure the arrays o\are ordered in ascending frequency
		sort_idx = np.argsort(obs.spectrum.frequency)
		obs.spectrum.frequency = obs.spectrum.frequency[sort_idx]
		obs.spectrum.Tb = obs.spectrum.Tb[sort_idx]
		pixel_dict[pixel].pixel = pixel
		pixel_dict[pixel].observation = obs
		pixel_dict[pixel].obs_x = obs.spectrum.frequency
		pixel_dict[pixel].obs_y = obs.spectrum.Tb
		pixel_dict[pixel].ra = pos_key[pixel][0]
		pixel_dict[pixel].dec = pos_key[pixel][1]
		pixel_dict[pixel].continuum = gen_continuum(fitting_variables.spectra_dir, obs, pixel, fitting_variables.cont_key)
		pixel_dict[pixel].coords = [int(pixel.split('_')[0]), int(pixel.split('_')[1])]
	
		#Initialize the dictionaries in Pixel.molecule_params to hold the fit information
		pixel_dict[pixel].molecule_params = dict()
		for mol in fitting_variables.molecule_dict:
			pixel_dict[pixel].molecule_params[mol] = Molecule_Parameters()
	
		#Set the flex params for all pixels to the value provided in fitting_variables
		for mol in fitting_variables.molecule_dict:
		
			pixel_dict[pixel].molecule_params[mol].tex_flex = fitting_variables.tex_flex
			pixel_dict[pixel].molecule_params[mol].dV_flex = fitting_variables.dV_flex
			pixel_dict[pixel].molecule_params[mol].vlsr_flex = fitting_variables.vlsr_flex
			pixel_dict[pixel].molecule_params[mol].nt_flex = fitting_variables.nt_flex
		
			pixel_dict[pixel].molecule_params[mol].associated_molecules = fitting_variables.molecule_dict[mol]
		
		#Assign the necessary variables when the exclusion flag is True
		if fitting_variables.exclusion == True:
		
			#Need the list of continuum values for the eup threshold
			continuum_dict = file_to_dict(glob.glob(fitting_variables.spectra_dir+'*cont_values*')[0])
		
			for mol in fitting_variables.exclusion_dict:

				#Set the upper state energy thresholds for each molecule
				if fitting_variables.exclusion_dict[mol] == 'exclude':
					pixel_dict[pixel].molecule_params[mol].eup_threshold = np.inf

				else:
					pixel_dict[pixel].molecule_params[mol].eup_threshold = float(fitting_variables.exclusion_dict[mol]) * np.mean(continuum_dict[pixel])
			

	return pixel_dict

#Add an argument to decide whether moving over rows/columns
def pixel_hopping(pos_key, starting_pixel):
	#Generate dictionaries that define how the fitting routine will move around the image - starts at a pixel and branches out along both axes, but should handle using the edges as a starting point fine as well
	
	#pos_key is an output file from extract_spectra()
	starting_pixels_up = []
	starting_pixels_down = []
	pixel_list = []

	starting_col = starting_pixel.split('_')[0]
	starting_row = starting_pixel.split('_')[1]

	pixels = file_to_dict(pos_key)
	for pos in pixels:
		pixel_list.append(pos)
		if pos.split('_')[0] == starting_col and int(pos.split('_')[1]) <= int(starting_row):
			starting_pixels_down.append(pos)
		if pos.split('_')[0] == starting_col and int(pos.split('_')[1]) >= int(starting_row):
			starting_pixels_up.append(pos)
	
	#Make sure the two lists are in the appropriate order
	row_list = []
	for pixel in starting_pixels_up:
		row = int(pixel.split('_')[1])
		row_list.append(row)
	row_idx = np.argsort(row_list)
	starting_pixels_up = np.array(starting_pixels_up)[row_idx]
	
	row_list = []
	for pixel in starting_pixels_down:
		row = int(pixel.split('_')[1])
		row_list.append(row)
	row_idx = np.argsort(row_list)
	starting_pixels_down = np.array(starting_pixels_down)[row_idx]
	
# 	The elements of starting_pixels_down should be in descending order
	starting_pixels_down = np.array(list(reversed(starting_pixels_down)))
		
	#Dictionaries to maintain the proper order of the fit - key is the starting pixel, points to list of pixels to fit in order
	pixel_dict_r = dict()
	pixel_dict_l = dict()

	for start in starting_pixels_down:
		row = start.split('_')[1]
		for pixel in pixel_list:
			if row not in pixel_dict_r:
				pixel_dict_r[row] = list()
			if row not in pixel_dict_l:
				pixel_dict_l[row] = list()
			if pixel.split('_')[1] == row and int(pixel.split('_')[0]) >= int(starting_col):
				pixel_dict_r[row].append(pixel)
			if pixel.split('_')[1] == row and int(pixel.split('_')[0]) <= int(starting_col):
				pixel_dict_l[row].append(pixel)
			
	for start in starting_pixels_up:
		row = start.split('_')[1]
		for pixel in pixel_list:
			if row not in pixel_dict_r:
				pixel_dict_r[row] = list()
			if row not in pixel_dict_l:
				pixel_dict_l[row] = list()
			#Avoid double-counting the first row
			if row == starting_row:
				continue
			if int(pixel.split('_')[1]) == int(row) and int(pixel.split('_')[0]) >= int(starting_col):
				pixel_dict_r[row].append(pixel)
			if int(pixel.split('_')[1]) == int(row) and int(pixel.split('_')[0]) <= int(starting_col):
				pixel_dict_l[row].append(pixel)

	#The elements in each list of pixel_dict_l should be in descending order (right to left)
	for key in pixel_dict_l:
		pixel_dict_l[key] = list(reversed(pixel_dict_l[key]))
		
# 	for key in pixel_dict_r:
# 		print(key)
# 		print(pixel_dict_r[key])
# 	for key in pixel_dict_l:
# 		print(key)
# 		print(pixel_dict_l[key])
		
	return starting_pixels_up, starting_pixels_down, pixel_dict_r, pixel_dict_l

def calculate_tex(pixel, fitting_variables, exclusion=False):
	#Calculate the excitation temperature for a pixel assuming the brightest lines are optically thick
	
	#Have to set ll,ul using the unmasked observations
	ll,ul = find_limits(pixel.obs_x)
	
	h_cm = h * 1e7
	k_cm = 1.3807e-16
	
	if exclusion == False:
		inp_freq = pixel.obs_x
		inp_int = pixel.obs_y
	
		tex_list = []
		for i in range(len(ll)):
			sw_l = find_nearest(inp_freq, ll[i])
			sw_u = find_nearest(inp_freq, ul[i])
			
			#Exclude continuum values that are unphysical
			if continuum_values[i] < 3.:
				continue
			
			#Take only the frequencies/intensities from a single window
			sw_freqs = inp_freq[sw_l:sw_u]
			sw_ints = inp_int[sw_l:sw_u]
			#Sort the intensities in ascending order and reorganize the frequencies to match
			int_idx = np.argsort(sw_ints)
			sorted_ints = sw_ints[int_idx]
			sorted_freqs = sw_freqs[int_idx]
			#Want the mean of the intensities within 5 percent of the maximum value
			int_percentile = np.max(sw_ints)*0.95
			percentile_idx = find_nearest(sorted_ints, int_percentile)
			
			#The number of transitions within 1% of the max
			num_transitions = len(sorted_ints[percentile_idx:])
			
			#The actual Tex calculation
			#Convert each of the intensities to K THEN take the mean
			int_mean = 0
			for j in range(num_transitions):
				nu = sorted_freqs[percentile_idx+j]
				jy_beam = sorted_ints[percentile_idx+j]
				int_mean += 0.048 * nu*1e-3 / np.log( (3.92e-8 * (nu*1e-3)**3 * 0.26**2 / jy_beam) + 1. )
			#Delta T_b in the equation
			tex_tbg = int_mean / num_transitions
			#Calculate value for J(Tbg) using the mean frequency of the spw
			nu = 1e6*np.mean(inp_freq[sw_l:sw_u])
			jtbg = (h_cm*nu/k_cm)*(np.exp(h_cm*nu/(k_cm*continuum_values[i])) - 1. )**-1
			#Combine previous values for J(Tex)
			jtex = tex_tbg + jtbg
			#Solve for Tex from previous value
			sw_tex = h_cm*nu/k_cm * np.log(h_cm*nu/(k_cm*jtex) + 1. )**-1
			#Have Tex for one spectral window, repeat for each one
			tex_list.append(sw_tex)
			
		return np.mean(tex_list)
	
	elif use_mask == True:
		
		inp_freq = pixel.obs_x[pixel.excluded_channels]
		inp_int = pixel.obs_y[pixel.excluded_channels]
		
		tex_list_masked = []
		#List to hold the uncertainty in value from each spectral window
		tb_unc_list = []
		jtbg_unc_list = []
		sw_tex_unc_list = []
		for i in range(len(ll)):
			sw_l = find_nearest(inp_freq, ll[i])
			sw_u = find_nearest(inp_freq, ul[i])
			
			#Tbg can dip to unrealistic values, skip the worst offenders (also breaks the uncertainty calculation if tbg goes to 0)
			if continuum_values[i] < 3.:
				continue
			
			#Take only the frequencies/intensities from a single window
			sw_freqs = inp_freq[sw_l:sw_u]
			sw_ints = inp_int[sw_l:sw_u]
			#Sort the intensities in ascending order and reorganize the frequencies to match
			int_idx = np.argsort(sw_ints)
			sorted_ints = sw_ints[int_idx]
			sorted_freqs = sw_freqs[int_idx]
			#Want the mean of the intensities within 5 percent of the maximum value
			int_percentile = np.max(sw_ints)*0.95
			percentile_idx = find_nearest(sorted_ints, int_percentile)
			
			#The number of transitions within 1% of the max
			num_transitions = len(sorted_ints[percentile_idx:])
			
			#Value for uncertainty of T_B for the spectral window
			sw_unc_tb = 0
			#Add the error of each transition (10%) in quadrature, then divide by square root of number of transitions after converting to K
			for j in range(num_transitions):
				nu = sorted_freqs[percentile_idx+j]
				jy_beam = sorted_ints[percentile_idx+j]
				sw_unc_tb += (0.048 * nu*1e-3 / np.log( (3.92e-8 * (nu*1e-3)**3 * 0.26**2 / find_sigma_tb(nu,ll,ul)) + 1. ) )**2
			sw_unc = np.sqrt(sw_unc_tb/num_transitions)
			#Append the error in T_B for each window to a list
			tb_unc_list.append(sw_unc)
			
			#The actual Tex calculation
			#Convert each of the intensities to K THEN take the mean
			int_mean = 0
			for j in range(num_transitions):
				nu = sorted_freqs[percentile_idx+j]
				jy_beam = sorted_ints[percentile_idx+j]
				int_mean += 0.048 * nu*1e-3 / np.log( (3.92e-8 * (nu*1e-3)**3 * 0.26**2 / jy_beam) + 1. )
			#Delta T_b in the equation
			tex_tbg_masked = int_mean / num_transitions
			#Calculate value for J(Tbg) using the mean frequency of the spw
			nu = 1e6*np.mean(inp_freq[sw_l:sw_u])
			jtbg_masked = (h_cm*nu/k_cm)*(np.exp(h_cm*nu/(k_cm*continuum_values[i])) - 1. )**-1
			#Combine previous values for J(Tex)
			jtex_masked = tex_tbg_masked + jtbg_masked
			#Solve for Tex from previous value
			sw_tex = h_cm*nu/k_cm * np.log(h_cm*nu/(k_cm*jtex_masked) + 1. )**-1
			#Have Tex for one spectral window, repeat for each one
			tex_list_masked.append(sw_tex)
			
			#Value for uncertainty of J(Tbg) for the spectral window
			const = h_cm*nu/k_cm
			tbg = continuum_values[i]
			#Derivative of J(Tbg) wrt Tbg multiplied by uncertainty in Tbg
			sw_unc_jtbg = const**2*np.exp(const/tbg) / (tbg**2 * (np.exp(const/tbg)-1)**2 ) * 0.048 * nu*1e-9 / np.log( (3.92e-8 * (nu*1e-9)**3 * 0.26**2 / find_sigma_tbg(nu*1e-6,ll,ul)) + 1. )
			jtbg_unc_list.append(sw_unc_jtbg)
			
			#Plug the previous two uncertainties for T_B and J(Tbg) into our expression for the uncertainty in Tex for this spectral window
			#Then multiply by the uncertainty in J(Tex)
			sw_tex_unc = const**2 / (sw_tex*(const+sw_tex) * np.log((const+sw_tex)/sw_tex)**2 ) * np.sqrt(sw_unc**2+sw_unc_jtbg**2)
			sw_tex_unc_list.append(sw_tex_unc)
		
		#Combine the uncertainty calculated for each spectral window - rms?
		tex_unc_temp = 0
		for i in range(len(sw_tex_unc_list)):
			tex_unc_temp += (sw_tex_unc_list[i])**2
		tex_unc_final = np.sqrt(tex_unc_temp/len(sw_tex_unc_list))
		
		return np.mean(tex_list_masked), tex_unc_final

def calculate_dV(pixel, fitting_variables):
	
	def find_peaks(freq_arr,int_arr,res,min_sep,rms=None,sigma=3):
		#Return the indices at which peaks have been found in the spectra
		
		#The minimum separation in channel space between peaks
		chan_sep = min_sep/res
		
		#First pass to identify all the peaks in the spectra separated by the minimum distance
		indices = np.array(signal.find_peaks(int_arr,distance=chan_sep))[0]
		
		#Filter out peaks below the rms noise threshold
		if pixel.rms_noise is None:
			rms = get_rms(int_arr)
		else:
			rms = pixel.rms_noise
		indices = [x for x in indices if int_arr[x]>sigma*rms]
		indices = [x for x in indices if int_arr[x]>0]
		
		return np.array(indices) 
		
	def set_params(xval,yval,fwhm,fwhm_var):
		#Create lmfit Parameter object for the final Gaussian fit to the histogram
		
		params = Parameters()
		params.add('cen', value=xval, min=0.01)
		params.add('amp', value=yval)
		fwhm_min = fwhm-fwhm_var
		if fwhm_min < 0:
			fwhm_min = 0.0
		params.add('fwhm', value=fwhm, min=fwhm_min, max=fwhm+fwhm_var)
		
		return params
		
	def gaussianmin(params, x, data):
		#The minimization function that is applied to each peak in the spectrum
		
		cen = params['cen']
		amp = params['amp']
		fwhm = params['fwhm']
		fwhm_mhz = fwhm*x/2.998e5
		
		#Calculate the standard deviation from the FWHM using standard conversion factor
		wid = fwhm_mhz/2.35482
		
		model = (amp / (np.sqrt(2*np.pi) * wid)) * np.exp(-(x-cen)**2 / (2*wid**2))
		
		return model - data
		
	def do_fwhm(params,x_arr,y_arr):
		#Performs the minimization on one peak
		
		minner = Minimizer(gaussianmin, params, fcn_args=(x_arr, y_arr))
		result = minner.minimize()
		
		return result
		
	def fit_all(peak_xvals,peak_yvals,peak_idx,x_arr,y_arr,fwhm,fwhm_var,n_chans):
		#Fit Gaussians to all of the peaks in the spectra, return list of FWHMs and list of lmfit results
		
		output_fwhm = []
		result_list = []
		for xval,yval,peak_idx in zip(peak_xvals,peak_yvals,peak_idx):
			params = set_params(xval,yval,fwhm,fwhm_var)
			result = do_fwhm(params,x_arr[peak_idx-n_chans:peak_idx+n_chans+1],y_arr[peak_idx-n_chans:peak_idx+n_chans+1])
			
			#Calculate the channel width in km/s
			chan_width = (x_arr[peak_idx+1]-x_arr[peak_idx]) / x_arr[peak_idx+1] * 2.998e5
			
			#Deconvolve the channel width from the linewidth for the histogram - skip when fits < channel width (breaks the calculation)
			if result.params['fwhm'].value > chan_width:
				output_fwhm.append(np.sqrt(result.params['fwhm'].value**2 - chan_width**2))
				result_list.append(result)
				
		return output_fwhm, result_list
		
	def gaussianmin_fwhm(params, x, data):
		#The minimization function that is applied to the Gaussian fit to the histogram
		
		cen = params['cen']
		amp = params['amp']
		wid = params['fwhm']
		model = (amp / (np.sqrt(2*np.pi) * wid)) * np.exp(-(x-cen)**2 / (2*wid**2))
		
		return model - data
		
	def do_meta_fwhm(params,x_arr,y_arr):
		#Function for the Gaussian fit to the histogram
	
		minner = Minimizer(gaussianmin_fwhm, params, fcn_args=(x_arr, y_arr))
		result = minner.minimize()
		
		return result
	
	
	n_chans = fitting_variables.n_chans #2
	n_bins = fitting_variables.n_bins #100
	
	#Use the appropriate arrays for the observations
	if fitting_variables.exclusion == True:
		obs_x = pixel.obs_x[pixel.excluded_channels]
		obs_y = pixel.obs_y[pixel.excluded_channels]
	elif fitting_variables.exclusion == False:
		obs_x = pixel.obs_x
		obs_y = pixel.obs_y
	
	peak_idx = find_peaks(obs_x, obs_y,
	_get_res(pixel.obs_x), fitting_variables.min_sep, pixel.rms_noise, fitting_variables.sigma)
	
	peak_xvals = [obs_x[x] for x in peak_idx]
	peak_yvals = [obs_y[x] for x in peak_idx]
	
	#Exclude the first couple peaks in case the channel selection is out of range?
	out,out_results = fit_all(peak_xvals=peak_xvals[2:],peak_yvals=peak_yvals[2:],peak_idx=peak_idx[2:],
	x_arr=obs_x,y_arr=obs_y,fwhm=fitting_variables.initial_dV,
	fwhm_var=5.0,n_chans=n_chans) #Initial val for fwhm_var was 17.0, not sure why it was so high
	
	#Create the histogram of FWHM results
	frq,edges = np.histogram(out,bins=n_bins)
	
	params = set_params(xval=fitting_variables.initial_dV,yval=np.max(frq),fwhm=5.0,fwhm_var=10.0)
	result = do_meta_fwhm(params,edges[:-11],frq[:-10])
	
	#Reconvolve the channel width with the linewidth for the simulation
	#Should be safe to use the first two elements of the unmasked frequency array to find the channel spacing
	chan_width = (pixel.obs_x[1]-pixel.obs_x[0]) / pixel.obs_x[1] * 2.998e5
	fwhm = np.sqrt(result.params['cen'].value**2 + chan_width**2) #dv in kms
	
	return fwhm

def create_params(pixel, fitting_variables):
	#Create the Parameters object for the lmfit minimization

	#The Parameters object to be returned and passed to fit_spectra()
	fit_params = Parameters()
	
	#Calculate the rms noise for the column density minimum
	if fitting_variables.exclusion == True:
		pixel.excluded_channels = obs_exclusion(pixel, fitting_variables)
		obs_x = pixel.obs_x[pixel.excluded_channels]
		obs_y = pixel.obs_y[pixel.excluded_channels]
	elif fitting_variables.exclusion == False:
		obs_x = pixel.obs_x
		obs_y = pixel.obs_y
	
	#Bounds on the frequency of the observation after excluding appropriate channels
	ll,ul = find_limits(obs_x)
	
	rms_noise = get_rms(obs_y)
	#print(rms_noise)
	
	for mol in pixel.molecule_params:
		#Assuming fitting_variables.shared_tex is always True
		if 'tex' not in fit_params:
			#Using the minimizer to calculate tex
			#Take starting tex from the first molecule, will be the same for all molecules
			if fitting_variables.tex_calculation == 'minimizer':
				if pixel.molecule_params[mol].tex_flex is False:
					fit_params.add('tex', value=pixel.molecule_params[mol].init_tex)
				else: 
					fit_params.add('tex', value=pixel.molecule_params[mol].init_tex, 
					min=pixel.molecule_params[mol].init_tex - pixel.molecule_params[mol].tex_flex, 
					max=pixel.molecule_params[mol].init_tex + pixel.molecule_params[mol].tex_flex)
			#Instead making the assumption that the brightest lines are optically thick
			elif fitting_variables.tex_calculation == 'optically_thick':
				fit_params.add('tex', value=calculate_tex(pixel), vary=False)

		#Using the same dV for all molecules
		if fitting_variables.shared_dV == True:
			if 'dV' not in fit_params:
				#Using the minimizer to calculate dV
				if fitting_variables.dV_calculation == 'minimizer':
					if pixel.molecule_params[mol].dV_flex is False:
						fit_params.add('dV', value=pixel.molecule_params[mol].init_dV)
					else:
						fit_params.add('dV', value=pixel.molecule_params[mol].init_dV,
						min=pixel.molecule_params[mol].init_dV - pixel.molecule_params[mol].dV_flex,
						max=pixel.molecule_params[mol].init_dV + pixel.molecule_params[mol].dV_flex)
				#Using the histogram method to calculate dV
				elif fitting_variables.dV_calculation == 'histogram':
					fit_params.add('dV', value=calculate_dV(pixel,fitting_variables), vary=False)
		#Using a unique dV for all molecules - only works with using the minimizer
		else:
			fit_params.add(mol+'_dV', value=pixel.molecule_params[mol].init_dV,
			min=pixel.molecule_params[mol].init_dV - pixel.molecule_params[mol].dV_flex,
			max=pixel.molecule_params[mol].init_dV + pixel.molecule_params[mol].dV_flex)

		#Using the same vlsr for all molecules
		if fitting_variables.shared_vlsr == True:
			if 'vlsr' not in fit_params:
				if pixel.molecule_params[mol].vlsr_flex is False:
					fit_params.add('vlsr', value=pixel.molecule_params[mol].init_vlsr)
				else:
					fit_params.add('vlsr', value=pixel.molecule_params[mol].init_vlsr,
					min=pixel.molecule_params[mol].init_vlsr - pixel.molecule_params[mol].vlsr_flex,
					max=pixel.molecule_params[mol].init_vlsr + pixel.molecule_params[mol].vlsr_flex)

		#Using a unique vlsr for all molecules
		else:
			fit_params.add(mol+'_vlsr', value=pixel.molecule_params[mol].init_vlsr,
			min=pixel.molecule_params[mol].init_vlsr - pixel.molecule_params[mol].vlsr_flex,
			max=pixel.molecule_params[mol].init_vlsr + pixel.molecule_params[mol].vlsr_flex)
		
		#Restrict the lower limit on the column density if it's nearing the limit of detectability (lines have little positive emission)
		#If previous pixel already went below the limit then that value for nt will still be used
		#Could have undesired effects if the nt bounds are especially large, but should be fine for most cases
		
		mol_nt_max = pixel.molecule_params[mol].init_nt + pixel.molecule_params[mol].nt_flex
		
		sim_list = []
		
		#Iterate over each set of molecules associated with one key (likely just vib. states)
		for molecule in pixel.molecule_params[mol].associated_molecules:
		
			temp_source = Source(column=10**pixel.molecule_params[mol].init_nt,
								dV=pixel.molecule_params[mol].init_dV,
								velocity=pixel.molecule_params[mol].init_vlsr,
								Tex=pixel.molecule_params[mol].init_tex,
								continuum=pixel.continuum)

			temp_sim = Simulation(mol=molecule,
								  ll=ll, ul=ul,
								  observation=pixel.observation,
								  source=temp_source,
								  line_profile='Gaussian',
								  use_obs=True,
								  units='Jy/beam',
								  tau_threshold=pixel.molecule_params[mol].tau_threshold,
								  eup_threshold=pixel.molecule_params[mol].eup_threshold)

			#Handles if the molecule has no lines in the frequency range
			if len(temp_sim.spectrum.freq_profile) == 0:
				#print('No lines of '+mol+'!')
				continue
			
			#Each simulation gets appended to the list to be summed
			sim_list.append(temp_sim)
		
		#Prevents sum_spectra() from being run if all associated molecules have no lines in the spectra
		#Print statement makes it clear when a molecule can be safely removed from the list to fit
		try:
			summed_spectrum = sum_spectra(sim_list, override_freqs=obs_x, thin=False, 
										  Tex=pixel.molecule_params[mol].init_tex, Tbg=pixel.continuum, planck=True)
		except ValueError as e:
			print(f'Value error raised, {mol} has no lines in the data, recommend removal')

		pred_y = summed_spectrum.int_profile
		
		#Compare the maximum intensity of the simulation to the rms_noise - potential roundoff errors when checking if entire array is 0?
		if np.max(pred_y) < rms_noise:
			mol_nt_min = pixel.molecule_params[mol].init_nt
# 			print(f'if statement active for {mol}')
# 			print(np.max(pred_y), rms_noise)
			#Since the lower bound will be placed at the (current) initial guess, increase the value of the initial guess
			#Minimizer doesn't work correctly if the initial guess is close to a bound
			pixel.molecule_params[mol].init_nt = pixel.molecule_params[mol].init_nt + (0.5*pixel.molecule_params[mol].nt_flex)
		else:
			mol_nt_min = pixel.molecule_params[mol].init_nt - pixel.molecule_params[mol].nt_flex
		
		pixel.molecule_params[mol].min_nt = mol_nt_min
		pixel.molecule_params[mol].max_nt = mol_nt_max
		
		#Column densities will always be unique
		if fitting_variables.nt_flex is False:
			fit_params.add(mol+'_nt', value=pixel.molecule_params[mol].init_nt)
			
		else:
			fit_params.add(mol+'_nt', value=pixel.molecule_params[mol].init_nt,
			min=mol_nt_min,
			max=mol_nt_max)


	return fit_params

def store_params(pixel, pixel_dict, fitting_variables):
	#Store the initial and final values for pixel.molecule_params

	#Put the values in a dictionary to easily store/read
	output_dict = dict()
	for mol in pixel_dict[pixel].molecule_params:
	
		if mol not in output_dict:
			output_dict[mol] = dict()
		
		output_dict[mol]['tex'] = pixel_dict[pixel].molecule_params[mol].tex
		output_dict[mol]['init_tex'] = pixel_dict[pixel].molecule_params[mol].init_tex
		output_dict[mol]['tex_flex'] = pixel_dict[pixel].molecule_params[mol].tex_flex
		output_dict[mol]['dV'] = pixel_dict[pixel].molecule_params[mol].dV
		output_dict[mol]['init_dV'] = pixel_dict[pixel].molecule_params[mol].init_dV
		output_dict[mol]['dV_flex'] = pixel_dict[pixel].molecule_params[mol].dV_flex
		output_dict[mol]['vlsr'] = pixel_dict[pixel].molecule_params[mol].vlsr
		output_dict[mol]['init_vlsr'] = pixel_dict[pixel].molecule_params[mol].init_vlsr
		output_dict[mol]['vlsr_flex'] = pixel_dict[pixel].molecule_params[mol].vlsr_flex
		output_dict[mol]['nt'] = pixel_dict[pixel].molecule_params[mol].nt
		output_dict[mol]['init_nt'] = pixel_dict[pixel].molecule_params[mol].init_nt
		output_dict[mol]['nt_flex'] = pixel_dict[pixel].molecule_params[mol].nt_flex
		output_dict[mol]['nt_min'] = pixel_dict[pixel].molecule_params[mol].min_nt
		output_dict[mol]['nt_max'] = pixel_dict[pixel].molecule_params[mol].max_nt
		
		output_dict[mol]['eup_threshold'] = pixel_dict[pixel].molecule_params[mol].eup_threshold
		output_dict[mol]['tau_threshold'] = pixel_dict[pixel].molecule_params[mol].tau_threshold
		
# 		output_dict[mol]['associated_molecules'] = []
# 		for mol in pixel_dict[pixel].molecule_params[mol].associated_molecules:
# 			output_dict[mol]['associated_molecules'].append(mol.name)

	with open(fitting_variables.output_dir+fitting_variables.source+'_'+pixel+'.txt', 'w') as output:
		json.dump(output_dict, output)

	return

def read_params(pixel, pixel_dict, fitting_variables):
	#Take the file generated at the end of a fit and pull the initial and final values for pixel.molecule_params

	with open(fitting_variables.output_dir+fitting_variables.source+'_'+pixel+'.txt', 'r') as input:
		output_dict = json.load(input)

	for mol in pixel_dict[pixel].molecule_params:
	
		pixel_dict[pixel].molecule_params[mol].tex = output_dict[mol]['tex']
		pixel_dict[pixel].molecule_params[mol].init_tex = output_dict[mol]['init_tex']
		pixel_dict[pixel].molecule_params[mol].tex_flex = output_dict[mol]['tex_flex']
		pixel_dict[pixel].molecule_params[mol].dV = output_dict[mol]['dV']
		pixel_dict[pixel].molecule_params[mol].init_dV = output_dict[mol]['init_dV']
		pixel_dict[pixel].molecule_params[mol].dV_flex = output_dict[mol]['dV_flex']
		pixel_dict[pixel].molecule_params[mol].vlsr = output_dict[mol]['vlsr']
		pixel_dict[pixel].molecule_params[mol].init_vlsr = output_dict[mol]['init_vlsr']
		pixel_dict[pixel].molecule_params[mol].vlsr_flex = output_dict[mol]['vlsr_flex']
		pixel_dict[pixel].molecule_params[mol].nt = output_dict[mol]['nt']
		pixel_dict[pixel].molecule_params[mol].init_nt = output_dict[mol]['init_nt']
		pixel_dict[pixel].molecule_params[mol].nt_flex = output_dict[mol]['nt_flex']
		pixel_dict[pixel].molecule_params[mol].min_nt = output_dict[mol]['nt_min']
		pixel_dict[pixel].molecule_params[mol].max_nt = output_dict[mol]['nt_max']
		
		pixel_dict[pixel].molecule_params[mol].eup_threshold = output_dict[mol]['eup_threshold']
		pixel_dict[pixel].molecule_params[mol].tau_threshold = output_dict[mol]['tau_threshold']
		
# 		Update the associated molecules from strings to Molecule objects
# 		mol_strings = output_dict[mol]['associated_molecules']
# 		pixel_dict[pixel].molecule_params[mol].associated_molecules = 
		

	return

def update_params(pixel, fitting_variables):
	#Update the starting parameters for the first pixel if unique values are desired for the molecules

	for mol in fitting_variables.custom_params_dict:
	
		if 'nt' in fitting_variables.custom_params_dict[mol]:
			pixel.molecule_params[mol].init_nt = fitting_variables.custom_params_dict[mol]['nt']
		
		if 'vlsr' in fitting_variables.custom_params_dict[mol]:
			pixel.molecule_params[mol].init_vlsr = fitting_variables.custom_params_dict[mol]['vlsr']

		if 'dV' in fitting_variables.custom_params_dict[mol]:
			pixel.molecule_params[mol].init_dV = fitting_variables.custom_params_dict[mol]['dV']
		
	return

def calc_mean_params(pixel):
	#Calculate the mean parameter values for the purposes of generic values to pass when simulating exclusion molecules

	mean_param_dict = dict()
	mean_dV = 0
	mean_vlsr = 0
	mean_tex = 0

	for mol in pixel.molecule_params[mol]:
		mean_dV += pixel.molecule_params[mol].init_dV
		mean_vlsr += pixel.molecule_params[mol].init_vlsr
		mean_tex += pixel.molecule_params[mol].init_tex

	
	mean_param_dict['dV'] = mean_dV / len(pixel.molecule_params[mol])
	mean_param_dict['vlsr'] = mean_vlsr / len(pixel.molecule_params[mol])
	mean_param_dict['tex'] = mean_tex / len(pixel.molecule_params[mol])

	return mean_param_dict

def obs_exclusion(pixel, fitting_variables):
	#Exclude observation channels from being fit if they are contaminated with emission from molecules matching the exclusion criteria

	#Bounds on the frequency of the observation
	ll,ul = find_limits(pixel.obs_x)
	#List to hold all of the simulations from molecules with no upper state energy threshold applied
	total_list = []
	#List to hold all of the simulations with the upper state energy threshold applied
	excluded_list = []

	#Iterate over each key in the dictionary holding the molecular parameters
	for molecule in fitting_variables.exclusion_dict:
	
		if molecule in pixel.molecule_params:
		
			#Skip molecules that have no .eup_threshold
			if pixel.molecule_params[molecule].eup_threshold == None:
				continue

			#Iterate over each set of molecules associated with one key (likely just vib. states)
			for mol in pixel.molecule_params[molecule].associated_molecules:
			
				temp_source = Source(column=10**pixel.molecule_params[molecule].init_nt,
				dV=pixel.molecule_params[molecule].init_dV,
				velocity=pixel.molecule_params[molecule].init_vlsr,
				Tex=pixel.molecule_params[molecule].init_tex,
				continuum=pixel.continuum)

				excluded_sim = Simulation(mol=mol,
				ll=ll, ul=ul,
				observation=pixel.observation,
				source=temp_source,
				line_profile='Gaussian',
				use_obs=True,
				units='Jy/beam',
				tau_threshold=pixel.molecule_params[molecule].tau_threshold,
				eup_threshold=pixel.molecule_params[molecule].eup_threshold)

				total_sim = Simulation(mol=mol,
				ll=ll, ul=ul,
				observation=pixel.observation,
				source=temp_source,
				line_profile='Gaussian',
				use_obs=True,
				units='Jy/beam',
				tau_threshold=None,
				eup_threshold=None)

				#Add each simulation for each molecule to the respective list
				excluded_list.append(excluded_sim)
				total_list.append(total_sim)

				#Handles if the molecule has no lines in the frequency range after masking
				if len(excluded_sim.spectrum.freq_profile) == 0:
					print(f'No lines of {molecule} in frequnecy range!')
					return
			
		else:

			mean_params = calc_mean_params(pixel)
		
			temp_source = Source(column=10**start_params[molecule].nt,
			dV=pixel.mean_params['dV'],
			velocity=mean_params['vlsr'],
			Tex=mean_params['tex'],
			continuum=pixel.continuum)

			excluded_sim = Simulation(mol=mol,
			ll=ll, ul=ul,
			observation=pixel.observation,
			source=temp_source,
			line_profile='Gaussian',
			use_obs=True,
			units='Jy/beam',
			tau_threshold=pixel.molecule_params[molecule].tau_threshold,
			eup_threshold=pixel.molecule_params[molecule].eup_threshold)

			total_sim = Simulation(mol=mol,
			ll=ll, ul=ul,
			observation=pixel.observation,
			source=temp_source,
			line_profile='Gaussian',
			use_obs=True,
			units='Jy/beam',
			tau_threshold=None,
			eup_threshold=None)

			#Add each simulation for each molecule to the respective list
			excluded_list.append(excluded_sim)
			total_list.append(total_sim)

			#Handles if the molecule has no lines in the frequency range after masking
			if len(excluded_sim.spectrum.freq_profile) == 0:
				print(f'No lines of {molecule} in frequnecy range!')
				return

	#Add the simulations together for the total/excluded list of simulations - Tex should just be taken from the last molecule in the loop
	excluded_spectrum = sum_spectra(excluded_list, override_freqs=pixel.obs_x, thin=False, 
	Tex=pixel.molecule_params[molecule].init_tex, Tbg=pixel.continuum, planck=True)

	total_spectrum = sum_spectra(total_list, override_freqs=pixel.obs_x, thin=False, 
	Tex=pixel.molecule_params[molecule].init_tex, Tbg=pixel.continuum, planck=True)

	#Compare the two simulations; the channels where they differ will be masked, as those channels contain emission from transitions below the threshold
	obs_mask = np.array([x==y for x,y in zip(total_spectrum.int_profile,excluded_spectrum.int_profile)])

	#print('Masking about '+ str(int((1.-np.count_nonzero(obs_mask)/len(obs_mask))*100)) + '% of channels for current pixel')

	return obs_mask

def min_function(params, pixel, fitting_variables):
	#The minimization function to pass to lmfit

	param_dict = params.valuesdict()

	if fitting_variables.exclusion == True:
		pixel.excluded_channels = obs_exclusion(pixel, fitting_variables)
		obs_x = pixel.obs_x[pixel.excluded_channels]
		obs_y = pixel.obs_y[pixel.excluded_channels]
	elif fitting_variables.exclusion == False:
		obs_x = pixel.obs_x
		obs_y = pixel.obs_y

	#Bounds on the frequency of the observation after excluding appropriate channels
	ll,ul = find_limits(obs_x)

	#List to store each simulation so they can be properly combined with sum_spectra()
	sim_list = []

	if fitting_variables.shared_dV==True and fitting_variables.shared_vlsr==True:

		#Iterate over each key in the dictionary holding the molecular parameters
		for molecule in pixel.molecule_params:

			#Iterate over each set of molecules associated with one key (likely just vib. states)
			for mol in pixel.molecule_params[molecule].associated_molecules:
			
				temp_source = Source(column=10**param_dict[molecule+'_nt'],
									dV=param_dict['dV'],
									velocity=param_dict['vlsr'],
									Tex=param_dict['tex'],
									continuum=pixel.continuum)

				temp_sim = Simulation(mol=mol,
									  ll=ll, ul=ul,
									  observation=pixel.observation,
									  source=temp_source,
									  line_profile='Gaussian',
									  use_obs=True,
									  units='Jy/beam',
									  tau_threshold=pixel.molecule_params[molecule].tau_threshold,
									  eup_threshold=pixel.molecule_params[molecule].eup_threshold)

				#Handles if the molecule has no lines in the frequency range
				if len(temp_sim.spectrum.freq_profile) == 0:
					#print('No lines of '+mol.name+'!')
					continue

				#Each simulation gets appended to the list to be summed
				sim_list.append(temp_sim)

		summed_spectrum = sum_spectra(sim_list, override_freqs=obs_x, thin=False, 
									  Tex=param_dict['tex'], Tbg=pixel.continuum, planck=True)

		pred_y = summed_spectrum.int_profile

		#Minimization function seems to work better with larger numbers, so convert to mJy/beam
		mse = np.mean(np.square(obs_y*1000 - pred_y*1000))

		return mse

	elif fitting_variables.shared_dV==True and fitting_variables.shared_vlsr==False:

		#Iterate over each key in the dictionary holding the molecular parameters
		for molecule in pixel.molecule_params:

			#Iterate over each set of molecules associated with one key (likely just vib. states)
			for mol in pixel.molecule_params[molecule].associated_molecules:

				temp_source = Source(column=10**param_dict[molecule+'_nt'],
									dV=param_dict['dV'],
									velocity=param_dict[mol.name+'_vlsr'],
									Tex=param_dict['tex'],
									continuum=pixel.continuum)

				temp_sim = Simulation(mol=mol,
									  ll=ll, ul=ul,
									  observation=pixel.observation,
									  source=temp_source,
									  line_profile='Gaussian',
									  use_obs=True,
									  units='Jy/beam',
									  tau_threshold=pixel.molecule_params[molecule].tau_threshold,
									  eup_threshold=pixel.molecule_params[molecule].eup_threshold)

				#Handles if the molecule has no lines in the frequency range
				if len(temp_sim.spectrum.freq_profile) == 0:
					#print('No lines of '+mol.name+'!')
					continue

				#Each simulation gets appended to the list to be summed
				sim_list.append(temp_sim)

		summed_spectrum = sum_spectra(sim_list, override_freqs=obs_x, thin=False, 
									  Tex=param_dict['tex'], Tbg=pixel.continuum, planck=True)

		pred_y = summed_spectrum.int_profile

		#Minimization function seems to work better with larger numbers, so convert to mJy/beam
		mse = np.mean(np.square(obs_y*1000 - pred_y*1000))

		return mse

	elif fitting_variables.shared_dV==False and fitting_variables.shared_vlsr==False:

		#Iterate over each key in the dictionary holding the molecular parameters
		for molecule in pixel.molecule_params:

			#Iterate over each set of molecules associated with one key (likely just vib. states)
			for mol in pixel.molecule_params[molecule].associated_molecules:

				temp_source = Source(column=10**param_dict[molecule+'_nt'],
									dV=param_dict[mol.name+'_dV'],
									velocity=param_dict[mol.name+'_vlsr'],
									Tex=param_dict['tex'],
									continuum=pixel.continuum)

				temp_sim = Simulation(mol=mol,
									  ll=ll, ul=ul,
									  observation=pixel.observation,
									  source=temp_source,
									  line_profile='Gaussian',
									  use_obs=True,
									  units='Jy/beam',
									  tau_threshold=pixel.molecule_params[molecule].tau_threshold,
									  eup_threshold=pixel.molecule_params[molecule].eup_threshold)

				#Handles if the molecule has no lines in the frequency range
				if len(temp_sim.spectrum.freq_profile) == 0:
					#print('No lines of '+mol.name+'!')
					continue

				#Each simulation gets appended to the list to be summed
				sim_list.append(temp_sim)

		summed_spectrum = sum_spectra(sim_list, override_freqs=obs_x, thin=False, 
									  Tex=param_dict['tex'], Tbg=pixel.continuum, planck=True)

		pred_y = summed_spectrum.int_profile

		#Minimization function seems to work better with larger numbers, so convert to mJy/beam
		mse = np.mean(np.square(obs_y*1000 - pred_y*1000))

		return mse

def fit_initial_column(pixel_dict, fitting_variables, start_pixel='0_0', single_pixel=True):
	#The function call to fit either a single pixel or the entire initial column

	#Create the output directory if it doesn't exist
	pathlib.Path(fitting_variables.output_dir).mkdir(exist_ok=True)

	if single_pixel == True:

		#Initialize the parameters to the starting values specified in fitting_variables
		for mol in fitting_variables.molecule_dict:
			pixel_dict[start_pixel].molecule_params[mol].init_tex = fitting_variables.initial_tex
			pixel_dict[start_pixel].molecule_params[mol].init_dV = fitting_variables.initial_dV
			pixel_dict[start_pixel].molecule_params[mol].init_vlsr = fitting_variables.initial_vlsr
			pixel_dict[start_pixel].molecule_params[mol].init_nt = fitting_variables.initial_nt
		
			if fitting_variables.nt_flex_pixel_1 is not None:
				#Give the column density a wider parameter space for the first pixel
				pixel_dict[start_pixel].molecule_params[mol].nt_flex = fitting_variables.nt_flex_pixel_1
			
			if fitting_variables.custom_params_dict is not None:
				#Allow unique starting positions for molecules
				update_params(pixel_dict[start_pixel], fitting_variables)

		fit_params = create_params(pixel_dict[start_pixel], fitting_variables)
	
		print('Beginning the fit!', time.ctime())

		results = lmfit.minimize(min_function, fit_params, method='lbfgsb', args=(pixel_dict[start_pixel], fitting_variables) )
	
		print('Done with the fit!', time.ctime())
	
		#Update the Pixel with fit values
		results_vals = results.params.valuesdict()

		for mol in pixel_dict[start_pixel].molecule_params:

			pixel_dict[start_pixel].molecule_params[mol].tex = results_vals['tex']

			#Using the same dV for all molecules
			if fitting_variables.shared_dV == True:
				pixel_dict[start_pixel].molecule_params[mol].dV = results_vals['dV']
			#Using a unique dV for all molecules
			else:
				pixel_dict[start_pixel].molecule_params[mol].dV = results_vals[mol+'_dV']

			#Using the same vlsr for all molecules
			if fitting_variables.shared_vlsr == True:
				pixel_dict[start_pixel].molecule_params[mol].vlsr = results_vals['vlsr']
			#Using a unique vlsr for all molecules
			else:
				pixel_dict[start_pixel].molecule_params[mol].vlsr = results_vals[mol+'_vlsr']

			#Column densities will always be unique	
			pixel_dict[start_pixel].molecule_params[mol].nt = results_vals[mol+'_nt']
	
		#Store the fit parameters in a file
		store_params(start_pixel, pixel_dict, fitting_variables)
		
# 		Temporary Uncertainty output for ethoxy paper
# 		print(lmfit.fit_report(results))
# 		print(f'T_ex Unc.: {results.params["tex"].value}, {results.params["tex"].stderr}')
# 		print(f'dV Unc.: {results.params["dV"].stderr}')
# 		print(f'Vlsr Unc.: {results.params["vlsr"].stderr}')
# 		print(f'Ethoxy_nt Unc.: {results.params["methoxyethanol_nt"].stderr}')

		return


	else:

		#Initialize the parameters to the starting values specified in fitting_variables
		for mol in fitting_variables.molecule_dict:
			pixel_dict[start_pixel].molecule_params[mol].init_tex = fitting_variables.initial_tex
			pixel_dict[start_pixel].molecule_params[mol].init_dV = fitting_variables.initial_dV
			pixel_dict[start_pixel].molecule_params[mol].init_vlsr = fitting_variables.initial_vlsr
			pixel_dict[start_pixel].molecule_params[mol].init_nt = fitting_variables.initial_nt
		
			if fitting_variables.nt_flex_pixel_1 is not None:
				#Give the column density a wider parameter space for the first pixel
				pixel_dict[start_pixel].molecule_params[mol].nt_flex = fitting_variables.nt_flex_pixel_1

		fit_params = create_params(pixel_dict[start_pixel], fitting_variables)
	
		print('Beginning the fit!', time.ctime())

		results = lmfit.minimize(min_function, fit_params, method='lbfgsb', args=(pixel_dict[start_pixel], fitting_variables) )


# 		print('Done with the fit!', time.ctime())
	
		#results.pretty_print() ?

		#Update the Pixel with fit values
		results_vals = results.params.valuesdict()

		for mol in pixel_dict[start_pixel].molecule_params:

			pixel_dict[start_pixel].molecule_params[mol].tex = results_vals['tex']

			#Using the same dV for all molecules
			if fitting_variables.shared_dV == True:
				pixel_dict[start_pixel].molecule_params[mol].dV = results_vals['dV']
			#Using a unique dV for all molecules
			else:
				pixel_dict[start_pixel].molecule_params[mol].dV = results_vals[mol+'_dV']

			#Using the same vlsr for all molecules
			if fitting_variables.shared_vlsr == True:
				pixel_dict[start_pixel].molecule_params[mol].vlsr = results_vals['vlsr']
			#Using a unique vlsr for all molecules
			else:
				pixel_dict[start_pixel].molecule_params[mol].vlsr = results_vals[mol+'_vlsr']

			#Column densities will always be unique	
			pixel_dict[start_pixel].molecule_params[mol].nt = results_vals[mol+'_nt']

		#Store the fit parameters in a file
		store_params(start_pixel, pixel_dict, fitting_variables)
		
		#Create the pixel dictionaries that define how we move through the image
		pos_key = fitting_variables.spectra_dir+fitting_variables.source+'_pos_key.txt'
		starting_pixels_up, starting_pixels_down, pixel_dict_r, pixel_dict_l = pixel_hopping(pos_key, start_pixel)

		#Now loop through the pixels to the north of the starting pixel
		for pixel in starting_pixels_up:

			#Skip first iteration as the first pixel in the list should be start_pixel
			if pixel == starting_pixels_up[0]:
				prev_pixel = pixel
				continue

			pixel_dict[pixel].prev_pixel = pixel_dict[prev_pixel].pixel

			#Use the molecule_params from the previous pixel to set initial values for the current pixel
			for mol in pixel_dict[pixel].molecule_params:
				pixel_dict[pixel].molecule_params[mol].init_tex = pixel_dict[prev_pixel].molecule_params[mol].tex
				pixel_dict[pixel].molecule_params[mol].init_dV = pixel_dict[prev_pixel].molecule_params[mol].dV
				pixel_dict[pixel].molecule_params[mol].init_vlsr = pixel_dict[prev_pixel].molecule_params[mol].vlsr
				pixel_dict[pixel].molecule_params[mol].init_nt = pixel_dict[prev_pixel].molecule_params[mol].nt
			
			fit_params = create_params(pixel_dict[pixel], fitting_variables)
		
			print(f'Now fitting {pixel}, using {prev_pixel} as starting parameters', time.ctime())
			results = lmfit.minimize(min_function, fit_params, method='lbfgsb', args=(pixel_dict[pixel], fitting_variables) )

			#Update the Pixel with fit values
			results_vals = results.params.valuesdict()

			for mol in pixel_dict[pixel].molecule_params:

				pixel_dict[pixel].molecule_params[mol].tex = results_vals['tex']

				#Using the same dV for all molecules
				if fitting_variables.shared_dV == True:
					pixel_dict[pixel].molecule_params[mol].dV = results_vals['dV']
				#Using a unique dV for all molecules
				else:
					pixel_dict[pixel].molecule_params[mol].dV = results_vals[mol+'_dV']

				#Using the same vlsr for all molecules
				if fitting_variables.shared_vlsr == True:
					pixel_dict[pixel].molecule_params[mol].vlsr = results_vals['vlsr']
				#Using a unique vlsr for all molecules
				else:
					pixel_dict[pixel].molecule_params[mol].vlsr = results_vals[mol+'_vlsr']

				#Column densities will always be unique	
				pixel_dict[pixel].molecule_params[mol].nt = results_vals[mol+'_nt']

			#Store the fit parameters in a file
			store_params(pixel, pixel_dict, fitting_variables)   
			
			prev_pixel = pixel

		#Now loop through the pixels to the south of the starting pixel
		for pixel in starting_pixels_down:

			#Skip first iteration as the first pixel in the list should be start_pixel
			if pixel == starting_pixels_down[0]:
				prev_pixel = pixel
				continue
						
			pixel_dict[pixel].prev_pixel = pixel_dict[prev_pixel].pixel

			#Use the molecule_params from the previous pixel to set initial values for the current pixel
			for mol in pixel_dict[pixel].molecule_params:
				pixel_dict[pixel].molecule_params[mol].init_tex = pixel_dict[prev_pixel].molecule_params[mol].tex
				pixel_dict[pixel].molecule_params[mol].init_dV = pixel_dict[prev_pixel].molecule_params[mol].dV
				pixel_dict[pixel].molecule_params[mol].init_vlsr = pixel_dict[prev_pixel].molecule_params[mol].vlsr
				pixel_dict[pixel].molecule_params[mol].init_nt = pixel_dict[prev_pixel].molecule_params[mol].nt
			
			
			fit_params = create_params(pixel_dict[pixel], fitting_variables)
		
			print(f'Now fitting {pixel}, using {prev_pixel} as starting parameters', time.ctime())
			results = lmfit.minimize(min_function, fit_params, method='lbfgsb', args=(pixel_dict[pixel], fitting_variables) )

			#Update the Pixel with fit values
			results_vals = results.params.valuesdict()

			for mol in pixel_dict[pixel].molecule_params:

				pixel_dict[pixel].molecule_params[mol].tex = results_vals['tex']

				#Using the same dV for all molecules
				if fitting_variables.shared_dV == True:
					pixel_dict[pixel].molecule_params[mol].dV = results_vals['dV']
				#Using a unique dV for all molecules
				else:
					pixel_dict[pixel].molecule_params[mol].dV = results_vals[mol+'_dV']

				#Using the same vlsr for all molecules
				if fitting_variables.shared_vlsr == True:
					pixel_dict[pixel].molecule_params[mol].vlsr = results_vals['vlsr']
				#Using a unique vlsr for all molecules
				else:
					pixel_dict[pixel].molecule_params[mol].vlsr = results_vals[mol+'_vlsr']

				#Column densities will always be unique	
				pixel_dict[pixel].molecule_params[mol].nt = results_vals[mol+'_nt']

			#Store the fit parameters in a file
			store_params(pixel, pixel_dict, fitting_variables)   
		
			prev_pixel = pixel
		
def fit_row(row, pixel_dict, fitting_variables, start_pixel='0_0'):
	#The function call to fit a single row after the initial column is finished

	#Create the pixel dictionaries that define how we move through the image
	pos_key = fitting_variables.spectra_dir+fitting_variables.source+'_pos_key.txt'
	starting_pixels_up, starting_pixels_down, pixel_dict_r, pixel_dict_l = pixel_hopping(pos_key, start_pixel)
		
	col = start_pixel.split('_')[0]
	#The pixel that has already been fit in the initial column that we will branch out from
	first_pixel = col+'_'+str(row)
		
	#Now loop through the pixels to the right of the starting pixel
	for pixel in pixel_dict_r[str(row)]:
				
		#Skip first iteration as the first pixel in the list should be start_pixel
		if pixel == first_pixel:
			prev_pixel = pixel
			continue
	
		pixel_dict[pixel].prev_pixel = pixel_dict[prev_pixel].pixel
	
		#Use the molecule_params from the previous pixel to set initial values for the current pixel
		for mol in pixel_dict[pixel].molecule_params:
			pixel_dict[pixel].molecule_params[mol].init_tex = pixel_dict[prev_pixel].molecule_params[mol].tex
			pixel_dict[pixel].molecule_params[mol].init_dV = pixel_dict[prev_pixel].molecule_params[mol].dV
			pixel_dict[pixel].molecule_params[mol].init_vlsr = pixel_dict[prev_pixel].molecule_params[mol].vlsr
			pixel_dict[pixel].molecule_params[mol].init_nt = pixel_dict[prev_pixel].molecule_params[mol].nt
			
		fit_params = create_params(pixel_dict[pixel], fitting_variables)

		print(f'Now fitting {pixel}, using {prev_pixel} as starting parameters', time.ctime(), flush=True)
		results = lmfit.minimize(min_function, fit_params, method='lbfgsb', args=(pixel_dict[pixel], fitting_variables) )
	
	
		#Update the Pixel with fit values
		results_vals = results.params.valuesdict()

		for mol in pixel_dict[pixel].molecule_params:

			pixel_dict[pixel].molecule_params[mol].tex = results_vals['tex']

			#Using the same dV for all molecules
			if fitting_variables.shared_dV == True:
				pixel_dict[pixel].molecule_params[mol].dV = results_vals['dV']
			#Using a unique dV for all molecules
			else:
				pixel_dict[pixel].molecule_params[mol].dV = results_vals[mol+'_dV']

			#Using the same vlsr for all molecules
			if fitting_variables.shared_vlsr == True:
				pixel_dict[pixel].molecule_params[mol].vlsr = results_vals['vlsr']
			#Using a unique vlsr for all molecules
			else:
				pixel_dict[pixel].molecule_params[mol].vlsr = results_vals[mol+'_vlsr']

			#Column densities will always be unique	
			pixel_dict[pixel].molecule_params[mol].nt = results_vals[mol+'_nt']

		#Store the fit parameters in a file
		store_params(pixel, pixel_dict, fitting_variables)

		prev_pixel = pixel
		
	
	#Now loop through the pixels to the left of the starting pixel
	for pixel in pixel_dict_l[str(row)]:

		#Skip first iteration as the first pixel in the list should be start_pixel
		if pixel == first_pixel:
			prev_pixel = pixel
			continue

		pixel_dict[pixel].prev_pixel = pixel_dict[prev_pixel].pixel

		#Use the molecule_params from the previous pixel to set initial values for the current pixel
		for mol in pixel_dict[pixel].molecule_params:
			pixel_dict[pixel].molecule_params[mol].init_tex = pixel_dict[prev_pixel].molecule_params[mol].tex
			pixel_dict[pixel].molecule_params[mol].init_dV = pixel_dict[prev_pixel].molecule_params[mol].dV
			pixel_dict[pixel].molecule_params[mol].init_vlsr = pixel_dict[prev_pixel].molecule_params[mol].vlsr
			pixel_dict[pixel].molecule_params[mol].init_nt = pixel_dict[prev_pixel].molecule_params[mol].nt

		fit_params = create_params(pixel_dict[pixel], fitting_variables)

		print(f'Now fitting {pixel}, using {prev_pixel} as starting parameters', time.ctime(), flush=True)
		results = lmfit.minimize(min_function, fit_params, method='lbfgsb', args=(pixel_dict[pixel], fitting_variables) )

		#Update the Pixel with fit values
		results_vals = results.params.valuesdict()

		for mol in pixel_dict[pixel].molecule_params:

			pixel_dict[pixel].molecule_params[mol].tex = results_vals['tex']

			#Using the same dV for all molecules
			if fitting_variables.shared_dV == True:
				pixel_dict[pixel].molecule_params[mol].dV = results_vals['dV']
			#Using a unique dV for all molecules
			else:
				pixel_dict[pixel].molecule_params[mol].dV = results_vals[mol+'_dV']

			#Using the same vlsr for all molecules
			if fitting_variables.shared_vlsr == True:
				pixel_dict[pixel].molecule_params[mol].vlsr = results_vals['vlsr']
			#Using a unique vlsr for all molecules
			else:
				pixel_dict[pixel].molecule_params[mol].vlsr = results_vals[mol+'_vlsr']

			#Column densities will always be unique	
			pixel_dict[pixel].molecule_params[mol].nt = results_vals[mol+'_nt']

		#Store the fit parameters in a file
		store_params(pixel, pixel_dict, fitting_variables)

		prev_pixel = pixel
		
def mp_helper(arg_list):
	#Can only pass one argument to the function when running in parallel, so need a helper function
		
	fit_row(arg_list[0],arg_list[1],arg_list[2],arg_list[3])
		
	return
	
def fit_multiprocessing(rows, n_cores, start_pixel, pixel_dict, fitting_variables):
	#Function to call that will fit the defined rows while utilizing the multiple cores in the CPU
		
	mp_args = []
	for row in rows:
		mp_args.append((row,pixel_dict.copy(),fitting_variables,start_pixel))
		
	with ProcessPoolExecutor(max_workers=n_cores) as executor:
		executor.map(mp_helper, mp_args)
			
	return
	
def plot_fit(pixel, pixel_dict, fitting_variables, show_sum=True, highlight_molecules=None, figsize= (10,5), savefig=False):
	#Plotting function for a python notebook / jupyter lab
	
	plt.figure(figsize = figsize)

	plt.plot(pixel_dict[pixel].obs_x, pixel_dict[pixel].obs_y, label='Observations', linewidth=1, alpha=1.)

	#Bounds on the frequency of the observation after excluding appropriate channels
	ll,ul = find_limits(pixel_dict[pixel].obs_x)

	if show_sum == True:
	
		#List to store each simulation so they can be properly combined with sum_spectra()
		sim_list = []
	
		#Iterate over each key in the dictionary holding the molecular parameters
		for molecule in pixel_dict[pixel].molecule_params:

			#Iterate over each set of molecules associated with one key (likely just vib. states)
			for mol in pixel_dict[pixel].molecule_params[molecule].associated_molecules:

				temp_source = Source(column=10**pixel_dict[pixel].molecule_params[molecule].nt,
									dV=pixel_dict[pixel].molecule_params[molecule].dV,
									velocity=pixel_dict[pixel].molecule_params[molecule].vlsr,
									Tex=pixel_dict[pixel].molecule_params[molecule].tex,
									continuum=pixel_dict[pixel].continuum)
			
				temp_sim = Simulation(mol=mol,
									  ll=ll, ul=ul,
									  observation=pixel_dict[pixel].observation,
									  source=temp_source,
									  line_profile='Gaussian',
									  use_obs=True,
									  units='Jy/beam',
									  tau_threshold=pixel_dict[pixel].molecule_params[molecule].tau_threshold,
									  eup_threshold=pixel_dict[pixel].molecule_params[molecule].eup_threshold)

				#Handles if the molecule has no lines in the frequency range
				if len(temp_sim.spectrum.freq_profile) == 0:
					#print('No lines of '+mol.name+'!')
					continue

				#Each simulation gets appended to the list to be summed
				sim_list.append(temp_sim)

		summed_spectrum = sum_spectra(sim_list, override_freqs=pixel_dict[pixel].obs_x, thin=False, 
									  Tex=pixel_dict[pixel].molecule_params[molecule].tex, Tbg=pixel_dict[pixel].continuum, planck=True)

		pred_y = summed_spectrum.int_profile

		plt.plot(pixel_dict[pixel].obs_x, pred_y, label='Model Spectrum', linewidth=1., alpha=1.)
	

	if highlight_molecules is not None:
			
		#Iterate over each key in the dictionary holding the molecular parameters
		for molecule in highlight_molecules:
		
			sim_list = []

			#Iterate over each set of molecules associated with one key (likely just vib. states)
			for mol in pixel_dict[pixel].molecule_params[molecule].associated_molecules:

				temp_source = Source(column=10**pixel_dict[pixel].molecule_params[molecule].nt,
									dV=pixel_dict[pixel].molecule_params[molecule].dV,
									velocity=pixel_dict[pixel].molecule_params[molecule].vlsr,
									Tex=pixel_dict[pixel].molecule_params[molecule].tex,
									continuum=pixel_dict[pixel].continuum)

				temp_sim = Simulation(mol=mol,
									  ll=ll, ul=ul,
									  observation=pixel_dict[pixel].observation,
									  source=temp_source,
									  line_profile='Gaussian',
									  use_obs=True,
									  units='Jy/beam',
									  tau_threshold=pixel_dict[pixel].molecule_params[molecule].tau_threshold,
									  eup_threshold=pixel_dict[pixel].molecule_params[molecule].eup_threshold)

				#Handles if the molecule has no lines in the frequency range
				if len(temp_sim.spectrum.freq_profile) == 0:
					#print('No lines of '+mol.name+'!')
					continue
					
# 				for freq,tau in zip(temp_sim.spectrum.frequency, temp_sim.spectrum.tau):
# 					print(freq, tau)

				#Each simulation gets appended to the list to be summed
				sim_list.append(temp_sim)

			summed_spectrum = sum_spectra(sim_list, override_freqs=pixel_dict[pixel].obs_x, thin=False, 
										  Tex=pixel_dict[pixel].molecule_params[molecule].tex, Tbg=pixel_dict[pixel].continuum, planck=True)

			pred_y = summed_spectrum.int_profile

			plt.plot(pixel_dict[pixel].obs_x, pred_y, label=molecule, linewidth=1.)
			
	plt.title(pixel)
	
	plt.xlabel('Frequency [MHz]')
	plt.ylabel('Intensity [Jy/beam]')
	
	plt.legend()
	
	if savefig is True:
		plt.savefig(fitting_variables.output_dir+pixel+'_spectrum.png', dpi=300)
		
	return
	
def plot_fit_multi(pixel_list, pixel_dict, fitting_variables, show_sum=True, highlight_molecules=None):
	#Plotting function for a python notebook / jupyter lab
	
	ax_list = []
	for i in range(len(pixel_list)):
		ax_list.append(matplotlib.axes)
	ax_tuple = tuple(ax_list)
	
	fig, ax_tuple = plt.subplots(len(pixel_list), sharex=True, sharey=True, figsize=(10,6))
	
	for i,(pixel,ax) in enumerate(zip(pixel_list,ax_tuple)):
	
		ax.plot(pixel_dict[pixel].obs_x, pixel_dict[pixel].obs_y, label='Observations')

		#Bounds on the frequency of the observation after excluding appropriate channels
		ll,ul = find_limits(pixel_dict[pixel].obs_x)

		if show_sum == True:
	
			#List to store each simulation so they can be properly combined with sum_spectra()
			sim_list = []
	
			#Iterate over each key in the dictionary holding the molecular parameters
			for molecule in pixel_dict[pixel].molecule_params:

				#Iterate over each set of molecules associated with one key (likely just vib. states)
				for mol in pixel_dict[pixel].molecule_params[molecule].associated_molecules:

					temp_source = Source(column=10**pixel_dict[pixel].molecule_params[molecule].nt,
										dV=pixel_dict[pixel].molecule_params[molecule].dV,
										velocity=pixel_dict[pixel].molecule_params[molecule].vlsr,
										Tex=pixel_dict[pixel].molecule_params[molecule].tex,
										continuum=pixel_dict[pixel].continuum)
			
					temp_sim = Simulation(mol=mol,
										  ll=ll, ul=ul,
										  observation=pixel_dict[pixel].observation,
										  source=temp_source,
										  line_profile='Gaussian',
										  use_obs=True,
										  units='Jy/beam',
										  tau_threshold=pixel_dict[pixel].molecule_params[molecule].tau_threshold,
										  eup_threshold=pixel_dict[pixel].molecule_params[molecule].eup_threshold)

					#Handles if the molecule has no lines in the frequency range
					if len(temp_sim.spectrum.freq_profile) == 0:
						#print('No lines of '+mol.name+'!')
						continue

					#Each simulation gets appended to the list to be summed
					sim_list.append(temp_sim)

			summed_spectrum = sum_spectra(sim_list, override_freqs=pixel_dict[pixel].obs_x, thin=False, 
										  Tex=pixel_dict[pixel].molecule_params[molecule].tex, Tbg=pixel_dict[pixel].continuum, planck=True)

			pred_y = summed_spectrum.int_profile

			ax.plot(pixel_dict[pixel].obs_x, pred_y, label='Model Spectrum')
	

		if highlight_molecules is not None:
			
			#Iterate over each key in the dictionary holding the molecular parameters
			for molecule in highlight_molecules:
		
				sim_list = []

				#Iterate over each set of molecules associated with one key (likely just vib. states)
				for mol in pixel_dict[pixel].molecule_params[molecule].associated_molecules:

					temp_source = Source(column=10**pixel_dict[pixel].molecule_params[molecule].nt,
										dV=pixel_dict[pixel].molecule_params[molecule].dV,
										velocity=pixel_dict[pixel].molecule_params[molecule].vlsr,
										Tex=pixel_dict[pixel].molecule_params[molecule].tex,
										continuum=pixel_dict[pixel].continuum)

					temp_sim = Simulation(mol=mol,
										  ll=ll, ul=ul,
										  observation=pixel_dict[pixel].observation,
										  source=temp_source,
										  line_profile='Gaussian',
										  use_obs=True,
										  units='Jy/beam',
										  tau_threshold=pixel_dict[pixel].molecule_params[molecule].tau_threshold,
										  eup_threshold=pixel_dict[pixel].molecule_params[molecule].eup_threshold)

					#Handles if the molecule has no lines in the frequency range
					if len(temp_sim.spectrum.freq_profile) == 0:
						#print('No lines of '+mol.name+'!')
						continue

					#Each simulation gets appended to the list to be summed
					sim_list.append(temp_sim)

				summed_spectrum = sum_spectra(sim_list, override_freqs=pixel_dict[pixel].obs_x, thin=False, 
											  Tex=pixel_dict[pixel].molecule_params[molecule].tex, Tbg=pixel_dict[pixel].continuum, planck=True)

				pred_y = summed_spectrum.int_profile

				ax.plot(pixel_dict[pixel].obs_x, pred_y, label=molecule)
			
		ax.set_title(pixel)
	
		ax.set_ylabel('Intensity [Jy/beam]')
		if i == len(pixel_list)-1:
			ax.set_xlabel('Frequency [MHz]')
			
		ax.legend(loc='upper right')
		
	return
	
def print_lines_from_fit(pixel, pixel_dict, fitting_variables, molecule, tau=None, eup=None, int_thresh=None):
	#Print out the transitions for the selected molecule

	ll,ul = find_limits(pixel_dict[pixel].obs_x)

	#Iterate over the set of molecules associated with the key (likely just vib. states)
	for mol in pixel_dict[pixel].molecule_params[molecule].associated_molecules:

		temp_source = Source(column=10**pixel_dict[pixel].molecule_params[molecule].nt,
							dV=pixel_dict[pixel].molecule_params[molecule].dV,
							velocity=pixel_dict[pixel].molecule_params[molecule].vlsr,
							Tex=pixel_dict[pixel].molecule_params[molecule].tex,
							continuum=pixel_dict[pixel].continuum)

		temp_sim = Simulation(mol=mol,
							  ll=ll, ul=ul,
							  observation=pixel_dict[pixel].observation,
							  source=temp_source,
							  line_profile='Gaussian',
							  use_obs=True,
							  units='Jy/beam',
							  tau_threshold=pixel_dict[pixel].molecule_params[molecule].tau_threshold,
							  eup_threshold=pixel_dict[pixel].molecule_params[molecule].eup_threshold)

		if len(temp_sim.spectrum.freq_profile) == 0:
			print(f'No lines of {mol.name}!')
			continue

	return temp_sim.print_lines(vlsr=pixel_dict[pixel].molecule_params[molecule].vlsr, eup_threshold=eup, threshold=int_thresh)
	
def gen_spectrum(molecule, pixel, pixel_dict, fitting_variables):
	#Return frequency and intensity arrays for a given molecule
	
	ll,ul = find_limits(pixel_dict[pixel].obs_x)
	
	#Hold the simulation for each associated molecule to be summed later
	sim_list = []
	
	#Loop over all the associated molecules (probably just vibrational states, if any)
	for mol in pixel_dict[pixel].molecule_params[molecule].associated_molecules:

		temp_source = Source(column=10**pixel_dict[pixel].molecule_params[molecule].nt,
							dV=pixel_dict[pixel].molecule_params[molecule].dV,
							velocity=pixel_dict[pixel].molecule_params[molecule].vlsr,
							Tex=pixel_dict[pixel].molecule_params[molecule].tex,
							continuum=pixel_dict[pixel].continuum)
	
		temp_sim = Simulation(mol=mol,
							  ll=ll, ul=ul,
							  observation=pixel_dict[pixel].observation,
							  source=temp_source,
							  line_profile='Gaussian',
							  use_obs=True,
							  units='Jy/beam',
							  tau_threshold=pixel_dict[pixel].molecule_params[molecule].tau_threshold,
							  eup_threshold=pixel_dict[pixel].molecule_params[molecule].eup_threshold)

		#Skip adding a simulation to the list if empty
		if len(temp_sim.spectrum.freq_profile) == 0:
			print(f'{mol.name} has no lines!')
			continue
			
		sim_list.append(temp_sim)
		
	summed_spectrum = sum_spectra(sim_list, override_freqs=pixel_dict[pixel].obs_x, thin=False, 
									Tex=pixel_dict[pixel].molecule_params[molecule].tex, Tbg=pixel_dict[pixel].continuum, planck=True)
									
	mol_intensity = summed_spectrum.int_profile

	return pixel_dict[pixel].obs_x, mol_intensity
	
def pull_fits_header_info(fits_example, pos_key_file, fitting_variables):
	#Pull the relevant header information from a .fits file so we can create .fits files from our results

	pos_key = file_to_dict(pos_key_file)

	#Pull the RA/Dec info from pos_key
	image_dict = dict()
	for pos in pos_key:
		if pos not in image_dict:
			image_dict[pos] = list() #(RA, Dec, Value)
		tempc = SkyCoord(pos_key[pos], unit=(u.hourangle, u.deg))
		image_dict[pos].append(tempc.ra.deg)
		image_dict[pos].append(tempc.dec.deg)

	with fits.open(fits_example) as hdu1:

		wcs_input_dict = {
			'CTYPE1': hdu1[0].header['CTYPE1'],
			'CUNIT1': hdu1[0].header['CUNIT1'],
			'CDELT1': hdu1[0].header['CDELT1'],
			'CRPIX1': 1.,
			'CRVAL1': image_dict['0_0'][0],
			'NAXIS1': fitting_variables.x_size,
			'CTYPE2': hdu1[0].header['CTYPE2'],
			'CUNIT2': hdu1[0].header['CUNIT2'],
			'CDELT2': hdu1[0].header['CDELT2'],
			'CRPIX2': 1.,
			'CRVAL2': image_dict['0_0'][1],
			'NAXIS2': fitting_variables.y_size
		}

	new_wcs = WCS(wcs_input_dict)
	output_hdul = new_wcs.to_fits()
	#from_output_wcs = WCS(header=output_hdul[0].header)

	return output_hdul

#Create the results directory early, or the fits_files/figures directory can't be made
def create_figure(parameter, pixel_dict, fitting_variables, make_fits=True, fits_info=None, make_png=True, figsize=(6,5), 
contours=[], ratio_mols=[], transition_thresh=None, noise_thresh=None, tex_thresh_upper=None, tex_thresh_lower=None):
	#Create .png/.fits images of the specified parameter

	if make_fits == True:
		pathlib.Path(fitting_variables.output_dir+'fits_files/').mkdir(exist_ok=True)
	
	if make_png == True:
		pathlib.Path(fitting_variables.output_dir+'figures/').mkdir(exist_ok=True)


	if parameter == 'continuum':
	
		continuum_dict = file_to_dict(glob.glob(fitting_variables.spectra_dir+'*cont_values*')[0])
	
		cont_spws = len(continuum_dict['0_0'])
		cont_fits = []
		for i in range(cont_spws):
			temp_cont = np.zeros((fitting_variables.x_size,fitting_variables.y_size))
			for i in range(fitting_variables.x_size):
				for j in range(fitting_variables.y_size):
					pos = str(i)+'_'+str(j)
					temp_cont[i,j] = continuum_dict[pos][0]
			cont_fits.append(temp_cont)
	
		cont_list = cont_fits
		for i in range(len(cont_list)):
		
			if make_png == True:
				plt.figure(figsize = figsize)
				plt.subplot(1, 1, 1, projection=WCS(header=fits_info[0].header))
			
				#Need to transpose the array so that it's oriented properly
				temp = np.transpose(cont_list[i])
				fits_info[0].data = temp
				plt.imshow(fits_info[0].data, cmap='gray')
				plt.colorbar(label='$T_{BG} [K]$')
				plt.xlabel('RA')
				plt.ylabel('Dec')
				plt.title('Background Temperature')
				plt.savefig(fitting_variables.output_dir+'figures/'+fitting_variables.source+'_tbg_'+str(i)+'.png')
				plt.close()
			
			if make_fits == True:
							
				fits_info[0].data = temp
				fits_info.writeto(fitting_variables.output_dir+'fits_files/'+fitting_variables.source+'_tbg_'+str(i)+'.fits', overwrite=True)
			
			
	elif parameter == 'tex':
	
		cvals = np.zeros((fitting_variables.x_size,fitting_variables.y_size))
	
		for i in range(fitting_variables.x_size):
			for j in range(fitting_variables.y_size):
				pos = str(i)+'_'+str(j)      
			
				#Pull a random molecule so we can get to the physical parameters
				temp_mol = list(pixel_dict[pos].molecule_params.keys())[0]
				
				if tex_thresh_upper is not None:
				
					if pixel_dict[pos].molecule_params[temp_mol].tex > tex_thresh_upper:
						cvals[i,j] = None
					else:
						cvals[i,j] = pixel_dict[pos].molecule_params[temp_mol].tex
						
		#Need to transpose the array so that it's oriented properly
		cvals = np.transpose(cvals)
	
		fits_info[0].data = cvals
				
		if make_png == True:
			plt.figure(figsize = figsize)
			plt.subplot(1, 1, 1, projection=WCS(header=fits_info[0].header))
			plt.imshow(fits_info[0].data, cmap='magma')
			plt.colorbar(label='T$_{ex}$ [K]')
			plt.xlabel('RA')
			plt.ylabel('Dec')
			plt.title('Excitation Temperature')
		
			if len(contours) > 0:
				hdu_contour = fits.open(fitting_variables.output_dir+'fits_files/'+fitting_variables.source+'_tbg_0.fits')
				plt.contour(hdu_contour[0].data, levels=contours, colors='white')
		
			plt.savefig(fitting_variables.output_dir+'figures/'+fitting_variables.source+'_'+parameter+'.png')
			plt.close()

		if make_fits == True:

			fits_info.writeto(fitting_variables.output_dir+'fits_files/'+fitting_variables.source+'_'+parameter+'.fits', overwrite=True)
		
		
	elif parameter == 'dV':
	
		cvals = np.zeros((fitting_variables.x_size,fitting_variables.y_size))
	
		for i in range(fitting_variables.x_size):
			for j in range(fitting_variables.y_size):
				pos = str(i)+'_'+str(j)      
			
				#Pull a random molecule so we can get to the physical parameters
				temp_mol = list(pixel_dict[pos].molecule_params.keys())[0]
				
				if tex_thresh_upper is not None:
				
					if pixel_dict[pos].molecule_params[temp_mol].tex > tex_thresh_upper:
						cvals[i,j] = None
					else:
						cvals[i,j] = pixel_dict[pos].molecule_params[temp_mol].dV
	
		#Need to transpose the array so that it's oriented properly
		cvals = np.transpose(cvals)
	
		fits_info[0].data = cvals
				
		if make_png == True:
			plt.figure(figsize = figsize)
			plt.subplot(1, 1, 1, projection=WCS(header=fits_info[0].header))
			plt.imshow(fits_info[0].data, cmap='magma')
			plt.colorbar(label='dV [km/s]')
			plt.xlabel('RA')
			plt.ylabel('Dec')
			plt.title('Linewidth')
		
			if len(contours) > 0:
				hdu_contour = fits.open(fitting_variables.output_dir+'fits_files/'+fitting_variables.source+'_tbg_0.fits')
				plt.contour(hdu_contour[0].data, levels=contours, colors='white')
		
			plt.savefig(fitting_variables.output_dir+'figures/'+fitting_variables.source+'_'+parameter+'.png')
			plt.close()

		if make_fits == True:

			fits_info.writeto(fitting_variables.output_dir+'fits_files/'+fitting_variables.source+'_'+parameter+'.fits', overwrite=True)
		
		
	elif parameter == 'vlsr':
	
		cvals = np.zeros((fitting_variables.x_size,fitting_variables.y_size))
	
		for i in range(fitting_variables.x_size):
			for j in range(fitting_variables.y_size):
				pos = str(i)+'_'+str(j)
			
				#Pull a random molecule so we can get to the physical parameters
				temp_mol = list(pixel_dict[pos].molecule_params.keys())[0]
				
				if tex_thresh_upper is not None:
				
					if pixel_dict[pos].molecule_params[temp_mol].tex > tex_thresh_upper:
						cvals[i,j] = None
					else:
						cvals[i,j] = pixel_dict[pos].molecule_params[temp_mol].vlsr
	
		#Need to transpose the array so that it's oriented properly
		cvals = np.transpose(cvals)
	
		fits_info[0].data = cvals
				
		if make_png == True:
			plt.figure(figsize = figsize)
			plt.subplot(1, 1, 1, projection=WCS(header=fits_info[0].header))
			plt.imshow(fits_info[0].data, cmap='bwr')
			plt.colorbar(label='V$_{LSR}$ [km/s]')
			plt.xlabel('RA')
			plt.ylabel('Dec')
			plt.title('Velocity')
		
			if len(contours) > 0:
				hdu_contour = fits.open(fitting_variables.output_dir+'fits_files/'+fitting_variables.source+'_tbg_0.fits')
				plt.contour(hdu_contour[0].data, levels=contours, colors='white')
		
			plt.savefig(fitting_variables.output_dir+'figures/'+fitting_variables.source+'_'+parameter+'.png')
			plt.close()

		if make_fits == True:

			fits_info.writeto(fitting_variables.output_dir+'fits_files/'+fitting_variables.source+'_'+parameter+'.fits', overwrite=True)
	
	elif parameter == 'ratio':
	
		if make_fits == True:
			pathlib.Path(fitting_variables.output_dir+'fits_ratios/').mkdir(exist_ok=True)
	
		if make_png == True:
			pathlib.Path(fitting_variables.output_dir+'figures_ratios/').mkdir(exist_ok=True)
		
		cvals = np.zeros((fitting_variables.x_size,fitting_variables.y_size))
# 		cvals1 = np.zeros((fitting_variables.x_size,fitting_variables.y_size))
# 		cvals2 = np.zeros((fitting_variables.x_size,fitting_variables.y_size))
		
		mol1 = ratio_mols[0]
		mol2 = ratio_mols[1]
		
		for i in range(fitting_variables.x_size):
			for j in range(fitting_variables.y_size):
				pos = str(i)+'_'+str(j)
		
				if tex_thresh_upper is not None:
				
					if pixel_dict[pos].molecule_params[mol1].tex > tex_thresh_upper:
						cvals[i,j] = None
					else:
# 						cvals1[i,j] = pixel_dict[pos].molecule_params[mol1].nt
# 						cvals2[i,j] = pixel_dict[pos].molecule_params[mol2].nt
						
						cvals[i,j] = np.log10(10**pixel_dict[pos].molecule_params[mol1].nt / 
												10**pixel_dict[pos].molecule_params[mol2].nt)
				
		#Need to transpose the array so that it's oriented properly
# 		cvals1 = np.transpose(cvals1)
# 		cvals2 = np.transpose(cvals2)
		cvals = np.transpose(cvals)
		
		# fits_info[0].data = np.log10( 10**cvals1 / 10**cvals2 )
		fits_info[0].data = cvals
		
		if make_png == True:
			plt.figure(figsize = figsize)
			plt.subplot(1, 1, 1, projection=WCS(header=fits_info[0].header))
			plt.imshow(fits_info[0].data, cmap=cmasher.cosmic)
			plt.colorbar(label=f'Log$_{10}$($N_T[{mol1}] : N_T[{mol2}]$)')
			plt.xlabel('RA')
			plt.ylabel('Dec')
			plt.title(f'{mol1} / {mol2}')
		
			if len(contours) > 0:
				hdu_contour = fits.open(fitting_variables.output_dir+'fits_files/'+fitting_variables.source+'_tbg_0.fits')
				plt.contour(hdu_contour[0].data, levels=contours, colors='white')
		
			plt.savefig(fitting_variables.output_dir+'figures_ratios/'+fitting_variables.source+'_'+mol1+'_'+mol2+'.png')
			plt.close()

		if make_fits == True:

			fits_info.writeto(fitting_variables.output_dir+'fits_ratios/'+fitting_variables.source+'_'+mol1+'_'+mol2+'.fits', overwrite=True)
		
		
	#Everything left should just be a molecule string
	else:
	
		cvals = np.zeros((fitting_variables.x_size,fitting_variables.y_size))
		
		for i in range(fitting_variables.x_size):
			for j in range(fitting_variables.y_size):
				pos = str(i)+'_'+str(j)
				
				cvals[i,j] = pixel_dict[pos].molecule_params[parameter].nt
				
				if noise_thresh is not None and transition_thresh is not None:
					
					mol_x, mol_y = gen_spectrum(parameter, pos, pixel_dict, fitting_variables)
					peaks, _ = scipy.signal.find_peaks(mol_y, height=noise_thresh)
					num_transitions = len(peaks)
					
					if num_transitions < transition_thresh:
						cvals[i,j] = None
# 					else:
# 						cvals[i,j] = pixel_dict[pos].molecule_params[parameter].nt
						
				if tex_thresh_upper is not None:
				
					if pixel_dict[pos].molecule_params[parameter].tex > tex_thresh_upper:
						cvals[i,j] = None
# 					else:
# 						cvals[i,j] = pixel_dict[pos].molecule_params[parameter].nt
						
						
				if tex_thresh_lower is not None:
				
					if pixel_dict[pos].molecule_params[parameter].tex < tex_thresh_lower:
						cvals[i,j] = None
# 					else:
# 						cvals[i,j] = pixel_dict[pos].molecule_params[parameter].nt
						
# 				else:
# 					cvals[i,j] = pixel_dict[pos].molecule_params[parameter].nt
				
		#Need to transpose the array so that it's oriented properly
		cvals = np.transpose(cvals)
	
		fits_info[0].data = cvals
		
		if make_png == True:
			plt.figure(figsize = figsize)
			plt.subplot(1, 1, 1, projection=WCS(header=fits_info[0].header))
			plt.imshow(fits_info[0].data, cmap='viridis')
			plt.colorbar(label='Log$_{10}$($N_T$) [cm$^{-2}$]')
			plt.xlabel('RA')
			plt.ylabel('Dec')
			plt.title(f'{parameter} Column Density')
		
			if len(contours) > 0:
				hdu_contour = fits.open(fitting_variables.output_dir+'fits_files/'+fitting_variables.source+'_tbg_0.fits')
				plt.contour(hdu_contour[0].data, levels=contours, colors='white')
		
			plt.savefig(fitting_variables.output_dir+'figures/'+fitting_variables.source+'_'+parameter+'.png')
			plt.close()

		if make_fits == True:

			fits_info.writeto(fitting_variables.output_dir+'fits_files/'+fitting_variables.source+'_'+parameter+'.fits', overwrite=True)

	return
	
	